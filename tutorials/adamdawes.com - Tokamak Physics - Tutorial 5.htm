<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
	<title>adamdawes.com - Tokamak Physics - Tutorial 5</title>
    	<link rel="stylesheet" href="/styles/adamdawes.css?version=20090606" type="text/css" media="all">
	<link rel="stylesheet" type="text/css" href="/styles/menus.css?version=20090606">
	<!--[if IE]>
	<link rel="stylesheet" type="text/css" href="/styles/menusie.css">
	<![endif]-->
	<link href="/rss.html" rel="alternate" type="application/rss+xml" title="rss" />
</head>


<body>

    <div id="copyright"></div>

<table id="layoutTable" cellpadding="0" cellspacing="0">
<tr><td class="leftColumn">

	<a href="/index.html" class="logo"></a><a class="logo-preload"></a>
	&nbsp;

	<!-- Windows software -->
	<div class="menu">
	<ul>
	  <li><a href="/windows/index.html" title="Windows software"><div class="headerWindows"></div></a>
	    <ul>
	      <li><div class="linksWindows"><a class="linkpopup" href="/windows8/index.html">Windows 8 software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenuTitle">Applications</div></li>
	        <li><div class="linksSubMenu"><a href="/windows8/win8_rsscentral.html" title="Powerful RSS feed reader">RSS Central</a></div></li>
	        <li><div class="linksSubMenuTitle">Games</div></li>
	        <li><div class="linksSubMenu"><a href="/windows8/win8_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windows8/win8_frotz8.html" title="An interpreter for Interactive Fiction games">Frotz8</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windows8/win8_wordsup.html" title="A fun strategic word game for between 2 and 4 players">WordsUp</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksWindows"><a class="linkpopup" href="/books/index.html">Windows 8 Books</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/books/w8wp8gamedev.html" title="Windows 8 and Windows Phone 8 Game Development">Windows 8 and Windows Phone 8 Game Development</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksWindows"><a class="linkpopup" href="/windows/index.html">Windows software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenuTitle">Applications</div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_tellyprompter.html" title="UK TV listings guide and reminder service">TellyPrompter</a></div></li>
	        <li><div class="linksSubMenuTitle">Children's</div></li>
	        <li><div class="linksSubMenu"><a href="http://www.icangames.com/ican/games/presskeys.html" title="Fun game for 1-3 year old children">I Can Press Keys</a></div></li>
	        <li><div class="linksSubMenuTitle">Games</div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_hpursuit.html" title="Fast-paced action-packed arcade driving game">Highway Pursuit</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="linksSubMenuTitle">Screen savers</div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_scr_polymorf3d.html" title="An endless parade of spinning multicoloured 3D shapes">Polymorf 3D</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_scr_snowfall.html" title="A shower of beautiful snowflakes">SnowFall</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_scr_twinklegl.html" title="Showers of coloured stars">TwinkleGL</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	    </ul>
	  </li>
	  <li><div class="footerWindows"></div>
	</ul>
	</div>
	<!-- Windows Phone -->
	<div class="menu">
	<ul>
	  <li><a href="/wp7/index.html" title="Windows Phone software"><div class="headerWindowsMobile"></div></a>
	    <ul>

	      <li><div class="titleWindowsMobile">Windows Phone</div>

	      <li><div class="linksWindowsMobile"><a class="linkpopup" href="/wp7/index.html">Software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenuTitle">Applications</div></li>
	        <li><div class="linksSubMenu"><a href="/wp7/wp7_rsscentral.html" title="Powerful RSS feed reader">RSS Central</a></div></li>
	        <li><div class="linksSubMenuTitle">Games</div></li>
	        <li><div class="linksSubMenu"><a href="/wp7/wp7_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="linksSubMenu"><a href="/wp7/wordsup.html" title="Fun strategic word game for two to four players">WordsUp</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>

	      <li><div class="linksWindowsMobile"><a class="linkpopup" href="/books/index.html">Books</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/books/wp7gamedev.html" title="Windows Phone 7 Game Development">Windows Phone 7 Game Development</a></div></li>
	        <li><div class="linksSubMenu"><a href="/books/w8wp8gamedev.html" title="Windows 8 and Windows Phone 8 Game Development">Windows 8 and Windows Phone 8 Game Development</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>

	      <li><div class="sepWindowsMobile"></div>
	      <li><div class="titleWindowsMobile">Windows Mobile</div>

	      <li><div class="linksWindowsMobile"><a class="linkpopup" href="/windowsmobile/index.html">Software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenuTitle">Games</div></li>
	        <li><div class="linksSubMenu"><a href="/windowsmobile/winmob_gemdrops.html" title="Fun and frantic puzzle game">GemDrops</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windowsmobile/winmob_pocketzax.html" title="An interpreter for interactive fiction adventure games">PocketZax</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windowsmobile/winmob_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>

	      <li><div class="linksWindowsMobile"><a class="linkpopup" href="/books/index.html">Books</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/books/wmgamedev.html" title="Windows Mobile Game Development">Windows Mobile Game Development</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	    </ul>
	  </li>
	  <li><div class="footerWindowsMobile"></div>
	</ul>
	</div>
	<!-- Programming -->
	<div class="menu">
	<ul>
	  <li><a href="/programming/index.html" title="Programming"><div class="headerProgramming"></div></a>
	    <ul>
	      <li><div class="linksProgramming"><a class="linkpopup" href="/books/index.html">Books</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/books/wmgamedev.html" title="Windows Mobile Game Development">Windows Mobile Game Development</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksProgramming"><a class="link" href="/programming/tokamak/index.html">Tokamak Physics</a></div></li>
	      <li><div class="linksProgramming"><a class="link" href="/programming/vs2005/index.html">Visual Studio</a></div></li>
	      <li><div class="linksProgramming"><a class="link" href="/programming/vb/index.html">Visual Basic 6</a></div></li>
	      <li><div class="linksProgramming"><a class="link" href="/programming/windows/index.html">Windows</a></div></li>
	      <li><div class="linksProgramming"><a class="link" href="/programming/opl/index.html">OPL</a></div></li>
	    </ul>
	  </li>
	  <li><div class="footerProgramming"></div>
	</ul>
	</div>
	<!-- Retro gaming -->
	<div class="menu">
	<ul>
	  <li><a href="/retrogaming/index.html" title="Retro gaming"><div class="headerRetrogaming"></div></a>
	    <ul>
	      <li><div class="linksRetrogaming"><a class="linkpopup" href="/retrogaming/index.html">Retro Gamer articles</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/rg_04_pias.html" title="An article exploring the music chip from the Commodore 64">Play it again, SID</a></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/rg_08_bubblebobble.html" title="A trip to the wonderful world of Taito's Bubble Bobble">Bubble Trouble</a></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/rg_17_playtowin.html" title="Ever wondered who won all those fantastic 80s game competitions?">Play to Win</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksRetrogaming"><a class="linkpopup" href="/retrogaming/index.html">Arcade projects</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/mamecab.html" title="My upright MAME arcade cabinet">MAME Cabinet</a></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/drivingcab.html" title="A sit-down 'cockpit'-style driving cabinet">Driving Cabinet</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksRetrogaming"><a class="linkpopup" href="/retrogaming/index.html">Game guides</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/bbguide/index.html" title="Complete level guide for Bubble Bobble">Bubble Bobble</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	    </ul>
	  </li>
	  <li><div class="footerRetrogaming"></div>
	</ul>
	</div>
	<!-- Ringtones -->
<!--
	<div class="menu">
	<ul>
	  <li><a href="/nokia/index.html" title="Ring-tones"><div class="headerRingtones"></div></a>
	    <ul>
	      <li><div class="linksRingtones"><a class="link" href="/nokia/tones.html">Polyphonic ring-tones</a></div></li>
	      <li><div class="linksRingtones"><a class="link" href="/nokia/howto_ringtones_index.html">Transferring via WAP</a></div></li>
	    </ul>
	  </li>
	  <li><div class="footerRingtones"></div>
	</ul>
	</div>
-->
	<!-- Psion software -->
	<div class="menu">
	<ul>
	  <li><a href="/psion/index.html" title="Psion software"><div class="headerPsion"></div></a>
	    <ul>
	      <li><div class="linksPsion"><a class="linkpopup" href="/psion/index.html">EPOC software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/psion/epoc_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="linksSubMenu"><a href="/psion/epoc_reaction.html" title="Explosive turn-based strategy game">Chain Reaction</a></div></li>
	        <li><div class="linksSubMenu"><a href="/psion/epoc_blobs.html" title="Fast paced Tetris-style game">Blobs</a></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksPsion"><a class="linkpopup" href="/psion/index.html">SIBO software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/psion/sibo_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="linksSubMenu"><a href="/psion/sibo_reaction.html" title="Explosive turn-based strategy game">Chain Reaction</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	    </ul>
	  </li>
	  <li><div class="footerPsion"></div>
	</ul>
	</div>
	<!-- Amiga -->
	<div class="menu">
	<ul>
	  <li><a href="/amiga/index.html" title="Amiga software"><div class="headerAmiga"></div></a>
	    <ul>
	      <li><div class="linksAmiga"><a class="link" href="/amiga/index.html">Amiga software</a></div></li>
	    </ul>
	  </li>
	  <li><div class="footerAmiga"></div>
	</ul>
	</div>
	<!-- Miscellaneous -->
	<div class="menu">
	<ul>
	  <li><a href="/misc/index.html" title="Miscellaneous"><div class="headerMisc"></div></a>
	    <ul>
	      <li><div class="linksMisc"><a class="link" href="/oldnews.html">Old news</a></div></li>
	      <li><div class="linksMisc"><a class="link" href="/misc/links.html">Links</a></div></li>
	      <li><div class="linksMisc"><a class="link" href="/misc/donate.html">Donate</a></div></li>
	      <li><div class="linksMisc"><a class="link" href="/misc/contact.html">Contact me</a></div></li>
	    </ul>
	  </li>
	  <li><div class="footerMisc"></div>
	</ul>
	</div>
	<!-- Search -->
	<div class="navBox">
		<div class="headerSearch"></div>
		<div class="linksSearch" style="padding-bottom:8px">
			<div style="margin-left:6px">
			<!-- SiteSearch Google -->
			<FORM method=GET action="http://www.google.com/search">
			<input type=hidden name=ie value=UTF-8>
			<input type=hidden name=oe value=UTF-8>
			<center>
			
			<A HREF="http://www.google.com/"><img style="margin-bottom:10px" src="/styles/images/google-logo.gif" width="81" height="34" alt="Google" border="0"></A><br>
			<INPUT TYPE=text name=q size=21 maxlength=255 value="" style="text-align: center">
			<INPUT style="margin-top:5px" type=submit name=btnG VALUE="Search this site">
			<input type=hidden name=domains value="adamdawes.com"><input type=hidden name=sitesearch value="adamdawes.com" checked>
			</center>
			</FORM>
			<!-- SiteSearch Google -->
			</div>
		</div>
		<div class="footerSearch"></div>
	</div>


    <div class="headerSubMenu-preload"></div>
    <div class="linksSubMenu-preload"></div>
    <div class="footerSubMenu-preload"></div>

	
	<div id="minilogo"></div>
	
	
	
</td>
<td class="rightColumn">

	<div id="topNavigation">
		<div id="utilityLinks">
			<a href="/misc/contact.html" class="contact"></a>
			<a href="/misc/contact.html" class="contact-preload"></a>
			<a href="/index.html" class="home"></a>
			<a href="/index.html" class="home-preload"></a>
			<a href="http://twitter.com/AdamDawes575" style="float: right; height: 36px; overflow: hidden; margin-right: 20px;">
				<img src="/styles/images/twitter.png" />
		 	</a>
		 	<br clear="all">
		</div>
	</div>

	<div id="contentHeader">
		<div id="contentHeaderLeft"></div>
		<div id="contentHeaderMid"></div>
		<div id="contentHeaderRight"></div>
	</div>
	<div id="contentFrame">
	
		<div id="content">

    <!-- PAGE CONTENT STARTS HERE -->

    <div id="breadcrumbs"><a href="/index.html">Home</a><a href="../index.html">Programming</a><a href="index.html">Tokamak Physics</a>Tutorial 5, terrain callback</div>

	<img align="right" src="files/TutImage5.jpg" alt="Tutorial screenshot">
	<h2>Tutorial 5, terrain callback</h2>
	
	<p>In the previous tutorial we looked at the terrain mesh, and discovered 
	how it allows us to create a completely arbitrary surface composed of 
	triangles that are typically used to create a terrain. One of the 
	limitations of this, however, is that as the complexity of the terrain 
	grows, Tokamak will begin to slow down when it is performing its collision 
	detection.</p>

	<p>The reason for this is that it has to check each rigid body in your scene 
	against every single triangle in the terrain mesh. As the numbers of rigid 
	bodies and of triangles in your terrain increase, this can quickly lead to 
	situations where the physics becomes unworkably slow.</p>

	<p>One possible way to avoid this would be to divide your terrain up into 
	sections and repeatedly call the <code>SetTerrainMesh()</code> function each 
	time the focus of your scene moves from one region of the map to another. 
	There are two drawbacks to this, however: firstly it limits all of your 
	physics processing to a single section of the game world, and secondly it 
	gives rise to the possibility of a performance hit in Tokamak each time you 
	set a new mesh.</p>

	<p>To work around these problem, Tokamak provides an alternative way for you 
	to tell it about the triangles that form your terrain. Instead of giving the 
	entire terrain to the engine, it will call a function in your code every 
	time it updates the position of each rigid body. Your function is 
	responsible for returning a list of only the relevant triangles that the 
	body might potentially be colliding with.</p>

	<p>This has two major advantages over <code>SetTerrainMesh()</code>, as 
	follows:</p>

	<p>1. As you have knowledge about how your terrain fits together, you are 
	usually able to make a well judged calculation about exactly which triangles 
	are relevant for collision detection. This can take advantage of binary 
	space partitioning algorithms and can usually be easily reduced to just a 
	handful of triangles (eight or less on a grid-based terrain).</p>

	<p>2. It allows you to handle the collisions differently for each rigid 
	body. For example, some bodies may completely pass through the terrain by 
	not returning any triangles. Or you may have two sets of terrain, with some 
	bodies colliding with one set and some with the other. There are all sorts 
	of possibilities in this area that are simply not available using 
	<code>SetTerrainMesh()</code>.</p>

	<p>While the terrain callback may at first look a little daunting, it's 
	actually not too complicated. Much of this code is based on that of tutorial 
	4, so if you've not read that yet then this is probably a good time to do 
	so.</p>

	<p>The only real difference during the setup of the rigid bodies is the 
	addition of this code in the loop that creates our spheres inside 
	<code>InitPhysics()</code>:</p>
	
<blockquote class="code">
		// Set the index of the triangle into the UserData of the rigid body.
		// We can retrieve this in the Terrain callback in order to find
		// out which rigid body we're testing for.
		gSpheres[i]-&gt;SetUserData(i);
</blockquote>

	<p>This gives a unique number (1, 2 or 3) to each of the bodies. We'll use 
	this in the terrain callback to determine which sphere is being collision-
	checked. For the purposes of this code, we'll use this to highlight the 
	relevant triangles in a different colour for each sphere.</p>

	<p>The terrain mesh in this example is generated in exactly the same way as 
	in tutorial 4 (though the <code>SetTerrainHeights()</code> function returns 
	a much less random terrain this time -- essentially a bowl shape so that our 
	spheres roll around it). We still set up the <code>neTriangleMesh</code> 
	object, though this time it's a global variable as we'll refer to it in 
	several parts of the code.</p>

	<p>Now, the <code>BuildTerrainMesh()</code> procedure no longer calls 
	<code>SetTerrainMesh()</code> once it has built the triangle mesh. It simply 
	returns back to <code>InitPhysics</code>. The extra magic line in 
	<code>InitPhysics()</code> that initialises the terrain triangle callback is 
	as follows:</p>
	
<blockquote class="code">
	gSim-&gt;SetTerrainTriangleQueryCallback(TerrainQueryCallback);
</blockquote>

	<p>Once this has been executed, Tokamak knows that it needs to call the 
	function in your code called <code>TerrainQueryCallback()</code> every time 
	it is processing the position of a rigid body in order to get the list of 
	triangles it should test against for collisions.</p>

	<p>So far so good, now we get to the callback function itself. The header of 
	the function is shown here:</p>
	
<blockquote class="code">
void TerrainQueryCallback(const neV3 & minBound,
                          const neV3 & maxBound,		// bounds of object to test
                          s32         **candidateTriangles,	// indices of triangles to be tested
                          neTriangle  **triangles,		// all possible test triangles
                          neV3        **vertices,		// triangle vertices
                          s32         *candidateCount,		// number of candidate triangles
                          s32         *triangleCount,		// number of possible test triangles
                          neRigidBody *rb)			// body to test
{
</blockquote>

	<p>This looks a bit complicated at first, but really it's not too bad. Let's 
	take a look at each parameter:</p>
	
	<blockquote>
	<dl>
	
	<dt><code>const neV3 & minBound, const neV3 & maxBound</code>
	
	<dd><p>These two parameters pass two points into the function that form an 
	"axis-aligned bounding box" (commonly abbreviated to AABB) which completely 
	contains the rigid body. This essentially means that the lowest of all of 
	the X, Y and Z coordinates are passed in the <code>minBound</code> 
	parameter, and the highest of all the coordinates are passed in the 
	<code>maxBound</code> parameter.</p>

	<p>If you can't visualise that, here's an example in 2d:</p>
	
	<p align="center"><img src="files/05_AABB.gif" alt="Axis-Aligned Bounding Box"></p>

	<p>The black rectangle shows an axis-aligned bounding box around the blue 
	rectangle. Even though the blue rectangle is not aligned to the X and Y 
	axes, the AABB is. This allows the AABB to be described using just two 2D 
	points -- one at the bottom/left (the minimum X and Y values across all 
	vertices in the blue rectangle) and the other at the top/right (the maximum 
	X and Y values).</p>

	<p>The <code>minBound</code> and <code>maxBound</code> parameters provide 
	exactly the same information but in 3d. The two points describe a cuboid 
	that perfectly and completely contains the rigid body.</p>
	
	<dt><code>s32 **candidateTriangles</code>
	
	<dd><p>Provides a pointer to a pointer to the indices of the triangles to test against.</p>

	<p>Let's try that again in English, shall we?</p>

	<p>When we return from the function we will provide a full list of triangles 
	against which collision may be performed. However, we can tell Tokamak to 
	ignore most of those triangles and instead get it to use just a subset of 
	them. This parameter allows us to pass the indices of the triangles which 
	are to be used for collision detection.</p>

	<p>So if we return an array of 100 triangles but we only want triangles 10, 
	20, 30 and 40 to be used for collisions, we would return a pointer to an 
	array containing the values <code>{10, 20, 30, 40}</code>. This would result 
	in only those four triangles being used for the collision test despite the 
	fact that we returned the definitions of all 100, saving a lot of 
	unnecessary processing.</p>
	
	<dt><code>neTriangle **triangles</code>
	
	<dd><p>This is where we actually return the details of the triangles 
	described above. Again, we use this to return a pointer to an array of 
	neTriangle objects.</p>

	<p>As you'll know from the previous tutorial, each triangle details the 
	indices of each vertex within a vertex array rather than storing the actual 
	vertex positions, so we'll need to provide the vertex array too. Which 
	brings us to...</p>
	
	<dt><code>neV3 **vertices</code>
	
	<dd><p>A pointer into which we'll provide the address of an array of 
	vertices. This array must encompass every vertex referenced by the 
	<code>triangles</code> array, and defines the actual position of each vertex 
	in 3d space, just as in the previous tutorial.</p>
	
	<dt><code>s32 *candidateCount</code>
	
	<dd><p>A pointer to an integer value into which we place the number of 
	candidate triangles that are present in the <code>candidateTriangles</code> 
	array above.</p>
	
	<dt><code>s32 *triangleCount</code>
	
	<dd><p>A pointer to an integer value into which we place the total number of 
	triangles that are present in the <code>triangles</code> array above.</p>
	
	<dt><code>neRigidBody *rb</code>
	
	<dd><p>A pointer to the rigid body that is being tested for collisions. We 
	can use the body's User Data to retrieve more information about the body, as 
	shown below.</p>
	
	<p><em>Note:</em> If your code doesn't want to work with this parameter, you 
	may have an out-of-date version of the Tokamak SDK. The initial version of 
	the v1.2 SDK did not include this parameter. An updated version was released 
	shortly afterwards with the parameter restored -- download the latest 
	version if this is causing problems.
	
	</dl>
	</blockquote>

	<p>So now we know what all the parameters are for, it's time to figure out 
	what to do with them.</p>

	<p>There are two ways in which you can use the terrain callback. The first 
	of these is to add all of the triangles that are to be tested to the 
	<code>triangles</code> array, omitting any that are not relevant for the 
	collision check. In this case, the <code>candidateCount</code> and 
	<code>triangleCount</code> will both contain the same value (the number of 
	triangles in the <code>triangles</code> array). The 
	<code>candidateTriangles</code> array will list all of the triangles (so 
	index zero of the array will contain the value zero, index one will contain 
	the value one, etc.).</p>

	<p>The second way is to return the entire set of all possible triangles (the 
	entire terrain) in the <code>triangles</code> array, and inform Tokamak 
	which of them are relevant using the <code>candidateTriangles</code> array. 
	In this case the <code>candidateCount</code> will be the number of triangles 
	to be checked and the <code>triangleCount</code> will be the total number of 
	triangles in the terrain.</p>

	<p>Both of these are valid approaches, and you'll need to decide which is 
	more appropriate for your application. For our code we'll use the second 
	approach. The reason for this is that we already have valid arrays of 
	triangles and vertices in exactly the format Tokamak is expecting -- we 
	built them for our triangle mesh earlier on. Because we pass back a pointer 
	to an array, there's no bulk data copying to be done; we just return a 
	pointer to the existing array.</p>

	<p>That means that there's no work to do for the <code>triangles</code> or 
	<code>vertices</code> parameters, and we know the <code>triangleCount</code> 
	too. But we still need to work out the details for the candidate 
	triangles.</p>

	<p>The first thing we do is declare the variables needed to do this, as 
	follows:</p>
	
<blockquote class="code">
	static s32 sCandidateTriangles[TERRAIN_TRIANGLECOUNT];
	int iCandidateIndex = 0;
	int i, j;
	neV3 minTri, maxTri;
	float fThisX, fThisY, fThisZ;
</blockquote>

	<p>The <code>sCandidateTriangles</code> array is declared as 
	<code>static</code>. There are two important reasons for this: firstly, the 
	data will be used by Tokamak after the callback function has returned and 
	its variables have gone out-of-scope. Declaring the array as 
	<code>static</code> means that it will be retained in memory and the pointer 
	to its data will still be valid. The second reason is one of performance. 
	When the array is static, C++ will allocate memory for it at the beginning 
	of the application execution. That memory will stay valid until the 
	application terminates. A non-static array would need to be reallocated 
	every time the callback function is executed.</p>

	<p>This leads us to an important point about the terrain callback: this 
	function will potentially be executed hundreds of times for every call to 
	Tokamak's <code>Advance()</code> method. For this reason you should be 
	extremely careful with the complexity and execution speed of code within it. 
	Performing slow operations here could cause your whole application to slow 
	down for no apparent reason. You should avoid memory allocations and should 
	try to avoid any unnecessary calculations too.</p>

	<p>The next block of code in the function is as follows:</p>
	
<blockquote class="code">
	// Loop through each triangle in our terrain
	for (i=0; i&lt;gTriMesh.triangleCount; i++)
	{
		// Set the min and max X and Z values to be the first point in the triangle
		fThisX = gTriMesh.vertices[gTriMesh.triangles[i].indices[0]].n.X;
		fThisY = gTriMesh.vertices[gTriMesh.triangles[i].indices[0]].n.Y;
		fThisZ = gTriMesh.vertices[gTriMesh.triangles[i].indices[0]].n.Z;
		minTri.Set(fThisX, fThisY, fThisZ);
		maxTri.Set(fThisX, fThisY, fThisZ);

		// Loop for the other two points in the triangle in order to find the
		// minimum and maximum coordinate values across all three vertices.
		for (j=1; j&lt;3; j++)
		{
			fThisX = gTriMesh.vertices[gTriMesh.triangles[i].indices[j]].n.X;
			fThisY = gTriMesh.vertices[gTriMesh.triangles[i].indices[j]].n.Y;
			fThisZ = gTriMesh.vertices[gTriMesh.triangles[i].indices[j]].n.Z;
			if (fThisX &lt; minTri.n.X) minTri.n.X = fThisX;
			if (fThisY &lt; minTri.n.Y) minTri.n.Y = fThisY;
			if (fThisZ &lt; minTri.n.Z) minTri.n.Z = fThisZ;
			if (fThisX &gt; maxTri.n.X) maxTri.n.X = fThisX;
			if (fThisY &gt; maxTri.n.Y) maxTri.n.Y = fThisY;
			if (fThisZ &gt; maxTri.n.Z) maxTri.n.Z = fThisZ;
		}
</blockquote>

	<p>In this first part of the loop we're trying to find the minimum and 
	maximum values on the X, Y and Z axes -- essentially the AABB of each 
	triangle. As we are using a static terrain mesh we could (and should) 
	precalculate all of this, saving a lot of processor time within the 
	callback. In fact you'll find that if you increase the size of the terrain 
	up to just 25x25 or 35x35 quads, the performance will begin to severely 
	degrade. Precalculating all of these triangle AABBs would resolve the 
	problem. For the sake of clarity I've left the code as above.</p>

	<p>Once we know the AABB of the triangle, we can use the AABB of the rigid 
	body to determine whether the rigid body potentially intersects the 
	triangle. This is done by seeing whether the minimum position of the rigid 
	body in each axis is less than the maximum position of the triangle, and 
	also the maximum position of the rigid body is greater than the minimum 
	position of the triangle. If these conditions are all true across all three 
	axes, the rigid body and the triangle potentially intersect. This means that 
	the triangle should be included within the collision detection.</p>

<blockquote class="code">
		// Now we know the bounds of the triangle, do the bounds of the
		// rigid body fall within them?
		if (minBound.n.X &lt;= maxTri.n.X &amp;&amp; maxBound.n.X &gt;= minTri.n.X &amp;&amp; 
			minBound.n.Y &lt;= maxTri.n.Y &amp;&amp; maxBound.n.Y &gt;= minTri.n.Y &amp;&amp; 
			minBound.n.Z &lt;= maxTri.n.Z &amp;&amp; maxBound.n.Z &gt;= minTri.n.Z)
		{
			// Yes, the rigid body is vertically in line with this triangle.

			// Add this triangle to the array of candidate triangles.
			sCandidateTriangles[iCandidateIndex] = i;
			iCandidateIndex += 1;

			// Use the GetUserData method to retrieve the sphere index
			// we previously placed into the rigid body. We'll use this
			// as part of a binary shift so that each rigid body sets
			// a corresponding bit in the giTriangleActive array.
			giTriangleActive[i] |= 1 &lt;&lt; rb-&gt;GetUserData();
		}

	}
</blockquote>

	<p>When this occurs we add a new item to the 
	<code>sCandidateTriangles</code> array and increment the array index pointer 
	(which also serves as a count for the number of items added to the array). 
	We also set a value into the <code>giTriangleActive</code> array. This is a 
	global array used purely to provide visual feedback in the rendering loop 
	about which triangles are actually being included in the collision check. We 
	retrieve the User Data value that was placed into the rigid body during the 
	<code>InitPhysics()</code> function and use it to set up a bit-mask in the 
	array.</p>

	<p>Note that you can pass any unsigned integer into the User Data value of 
	the rigid body. This could be a pointer to a class or a data structure. If 
	you are wrapping your rigid bodies inside C++ classes, you can place a 
	pointer to the wrapper object inside each rigid body's User Data. This 
	allows you to easily retrieve the object data during the collision check 
	(which could then be used to control exactly how the check is 
	performed).</p>

	<p>When this loop completes, we actually have everything we need to pass 
	back to Tokamak. The final piece of code here sets all the values and array 
	addresses into the pointers that Tokamak has passed us:</p>

<blockquote class="code">
	// Now we've built the array of candidate triangles,
	// we return values back to Tokamak as follows:
	*candidateTriangles = sCandidateTriangles;
	*triangles = gTriMesh.triangles;
	*vertices = gTriMesh.vertices;
	*candidateCount = iCandidateIndex;
	*triangleCount = gTriMesh.triangleCount;
</blockquote>	

	<p><code>candidateTriangles</code> is given a pointer to the static array of 
	triangles we've constructed. <code>triangles</code> and 
	<code>vertices</code> are both pointed to the pre-constructed arrays that we 
	put into the triangle mesh during the call to <code>InitPhysics()</code>. 
	<code>candidateCount</code> is loaded with the number of triangles we added 
	to the <code>candidateTriangles</code> array, and <code>triangleCount</code> 
	gets the total number of triangles in the triangle mesh.</p>

	<p>The last major change to the code in this project is in the 
	<code>Render()</code> function. In order to draw the candidate triangles to 
	make the process clearer, I've modified the rendering of the terrain to draw 
	each triangle individually. For each one it checks to see whether the 
	triangle was involved with any collision check, and sets the ambient 
	lighting to include full red, green or blue depending on which of the 
	spheres was involved. This leads to a terribly inefficient piece of 
	rendering code, but I've written it this way because it's easy to read.</p>
	
<blockquote class="code">
		// Set the vertex and index stream for the terrain
		gD3DDevice-&gt;SetStreamSource(0,vbFloor,sizeof(strVertex));
		gD3DDevice-&gt;SetIndices(ibFloor, 0);
		// Reset the view matrix to the identity matrix
		dxLoadIdentity();
		dxApplyMatrix(gD3DDevice);
		// Draw the terrain
		for (i=0; i&lt;TERRAIN_TRIANGLECOUNT; i++)
		{
			// Assume the ambient light will be the "normal" colour
			iFloorColour = 0x00202020;
			// Set the red, green or blue components of the ambient
			// light to full strength if one of our spheres is over
			// this triangle so that we can highlight it.
			if (giTriangleActive[i] &amp; 1) iFloorColour |= 0x00ff0000;
			if (giTriangleActive[i] &amp; 2) iFloorColour |= 0x0000ff00;
			if (giTriangleActive[i] &amp; 4) iFloorColour |= 0x000000ff;

			// Set the ambient light so that this floor triangle is rendered
			// in the colour we've defined
			gD3DDevice-&gt;SetRenderState(D3DRS_AMBIENT,iFloorColour);

			// Set the vertex and index stream for the terrain
			gD3DDevice-&gt;SetStreamSource(0,vbFloor,sizeof(strVertex));
			gD3DDevice-&gt;SetIndices(ibFloor, 0);
			// Draw this triangle
			gD3DDevice-&gt;DrawIndexedPrimitive(D3DPT_TRIANGLELIST,
							0, TERRAIN_VERTEXCOUNT,
							i*3, 1);
		}

		// Reset ambient lighting for subsequent rendering
		gD3DDevice-&gt;SetRenderState(D3DRS_AMBIENT,0x00202020);
</blockquote>

	<p>When you run the project, you will notice that the spheres roll perfectly 
	normally, just as they would have done using the 
	<code>SetTerrainMesh()</code> call in the previous tutorial. The important 
	thing to note however is that only the triangles that light up in different 
	colours as the spheres roll around are actually being checked for 
	collisions. All other terrain triangles are completely ignored.</p>

	<p>It's also worth noting that when a rigid body "sleeps" (Tokamak stops 
	updating its position because it considers that body as stationary), the 
	coloured triangles under that sphere suddenly vanish. This is not a bug, but 
	one of the many optimisations in Tokamak that help to maintain its 
	exceptional performance. As soon as the body is sleeping, Tokamak stops 
	performing any collision checks against the terrain until another rigid body 
	(or the application of a force upon the body from within your program code) 
	wakes it up again.</p>

	<p>That concludes this tutorial. The source code and a compiled executable 
	for this tutorial are available in the following .zip file.</p>
	
	<center>
	<a href="files/TokamakTutorial5.zip"><img src="../../gfx/ico_zip.gif" border="0" alt="Zip icon"></a>
	<br>
	<a href="files/TokamakTutorial5.zip">TokamakTutorial5.zip</a>
	</center>
 
	<table width="100%">
	 <tr>
	  <td align="left">&lt;&lt; <a href="04_TerrainMesh.html">Tutorial 4, terrain mesh</a> &lt;&lt;</td>
	  <td align="right"></td>
	 </tr>
	</table>

	<hr>
	<p>If you have any comments or suggestions regarding this article, please don't hesitate to <a href="../../misc/contact.html">contact me</a>.</p>
	<p align="right"><font size=-2>This article is copyright &copy; Adam Dawes, 2004.<br>It may not be copied or redistributed without my express written permission.</font></p>

    <!-- PAGE CONTENT ENDS HERE -->

    		</div>
		
	</div>

	<div id="contentFooter">
		<div id="contentFooterLeft"></div>
		<div id="contentFooterMid"></div>
		<div id="contentFooterRight"></div>
	</div>

</td></tr>
</table>

<script type="text/javascript">
//<![CDATA[
(function() {
	var links = document.getElementsByTagName('a');
	var query = '?';
	for(var i = 0; i < links.length; i++) {
		if(links[i].href.indexOf('#disqus_thread') >= 0) {
			query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
		}
	}
	document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/adamdawes/get_num_replies.js' + query + '"></' + 'script>');
})();
//]]>
</script>

</body>

</html>
