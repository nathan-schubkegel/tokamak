<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
    <title>adamdawes.com - Tokamak Physics - Tutorial 2</title>
    	<link rel="stylesheet" href="/styles/adamdawes.css?version=20090606" type="text/css" media="all">
	<link rel="stylesheet" type="text/css" href="/styles/menus.css?version=20090606">
	<!--[if IE]>
	<link rel="stylesheet" type="text/css" href="/styles/menusie.css">
	<![endif]-->
	<link href="/rss.html" rel="alternate" type="application/rss+xml" title="rss" />
</head>


<body>

    <div id="copyright"></div>

<table id="layoutTable" cellpadding="0" cellspacing="0">
<tr><td class="leftColumn">

	<a href="/index.html" class="logo"></a><a class="logo-preload"></a>
	&nbsp;

	<!-- Windows software -->
	<div class="menu">
	<ul>
	  <li><a href="/windows/index.html" title="Windows software"><div class="headerWindows"></div></a>
	    <ul>
	      <li><div class="linksWindows"><a class="linkpopup" href="/windows8/index.html">Windows 8 software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenuTitle">Applications</div></li>
	        <li><div class="linksSubMenu"><a href="/windows8/win8_rsscentral.html" title="Powerful RSS feed reader">RSS Central</a></div></li>
	        <li><div class="linksSubMenuTitle">Games</div></li>
	        <li><div class="linksSubMenu"><a href="/windows8/win8_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windows8/win8_frotz8.html" title="An interpreter for Interactive Fiction games">Frotz8</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windows8/win8_wordsup.html" title="A fun strategic word game for between 2 and 4 players">WordsUp</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksWindows"><a class="linkpopup" href="/books/index.html">Windows 8 Books</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/books/w8wp8gamedev.html" title="Windows 8 and Windows Phone 8 Game Development">Windows 8 and Windows Phone 8 Game Development</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksWindows"><a class="linkpopup" href="/windows/index.html">Windows software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenuTitle">Applications</div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_tellyprompter.html" title="UK TV listings guide and reminder service">TellyPrompter</a></div></li>
	        <li><div class="linksSubMenuTitle">Children's</div></li>
	        <li><div class="linksSubMenu"><a href="http://www.icangames.com/ican/games/presskeys.html" title="Fun game for 1-3 year old children">I Can Press Keys</a></div></li>
	        <li><div class="linksSubMenuTitle">Games</div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_hpursuit.html" title="Fast-paced action-packed arcade driving game">Highway Pursuit</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="linksSubMenuTitle">Screen savers</div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_scr_polymorf3d.html" title="An endless parade of spinning multicoloured 3D shapes">Polymorf 3D</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_scr_snowfall.html" title="A shower of beautiful snowflakes">SnowFall</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windows/win_scr_twinklegl.html" title="Showers of coloured stars">TwinkleGL</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	    </ul>
	  </li>
	  <li><div class="footerWindows"></div>
	</ul>
	</div>
	<!-- Windows Phone -->
	<div class="menu">
	<ul>
	  <li><a href="/wp7/index.html" title="Windows Phone software"><div class="headerWindowsMobile"></div></a>
	    <ul>

	      <li><div class="titleWindowsMobile">Windows Phone</div>

	      <li><div class="linksWindowsMobile"><a class="linkpopup" href="/wp7/index.html">Software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenuTitle">Applications</div></li>
	        <li><div class="linksSubMenu"><a href="/wp7/wp7_rsscentral.html" title="Powerful RSS feed reader">RSS Central</a></div></li>
	        <li><div class="linksSubMenuTitle">Games</div></li>
	        <li><div class="linksSubMenu"><a href="/wp7/wp7_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="linksSubMenu"><a href="/wp7/wordsup.html" title="Fun strategic word game for two to four players">WordsUp</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>

	      <li><div class="linksWindowsMobile"><a class="linkpopup" href="/books/index.html">Books</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/books/wp7gamedev.html" title="Windows Phone 7 Game Development">Windows Phone 7 Game Development</a></div></li>
	        <li><div class="linksSubMenu"><a href="/books/w8wp8gamedev.html" title="Windows 8 and Windows Phone 8 Game Development">Windows 8 and Windows Phone 8 Game Development</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>

	      <li><div class="sepWindowsMobile"></div>
	      <li><div class="titleWindowsMobile">Windows Mobile</div>

	      <li><div class="linksWindowsMobile"><a class="linkpopup" href="/windowsmobile/index.html">Software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenuTitle">Games</div></li>
	        <li><div class="linksSubMenu"><a href="/windowsmobile/winmob_gemdrops.html" title="Fun and frantic puzzle game">GemDrops</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windowsmobile/winmob_pocketzax.html" title="An interpreter for interactive fiction adventure games">PocketZax</a></div></li>
	        <li><div class="linksSubMenu"><a href="/windowsmobile/winmob_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>

	      <li><div class="linksWindowsMobile"><a class="linkpopup" href="/books/index.html">Books</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/books/wmgamedev.html" title="Windows Mobile Game Development">Windows Mobile Game Development</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	    </ul>
	  </li>
	  <li><div class="footerWindowsMobile"></div>
	</ul>
	</div>
	<!-- Programming -->
	<div class="menu">
	<ul>
	  <li><a href="/programming/index.html" title="Programming"><div class="headerProgramming"></div></a>
	    <ul>
	      <li><div class="linksProgramming"><a class="linkpopup" href="/books/index.html">Books</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/books/wmgamedev.html" title="Windows Mobile Game Development">Windows Mobile Game Development</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksProgramming"><a class="link" href="/programming/tokamak/index.html">Tokamak Physics</a></div></li>
	      <li><div class="linksProgramming"><a class="link" href="/programming/vs2005/index.html">Visual Studio</a></div></li>
	      <li><div class="linksProgramming"><a class="link" href="/programming/vb/index.html">Visual Basic 6</a></div></li>
	      <li><div class="linksProgramming"><a class="link" href="/programming/windows/index.html">Windows</a></div></li>
	      <li><div class="linksProgramming"><a class="link" href="/programming/opl/index.html">OPL</a></div></li>
	    </ul>
	  </li>
	  <li><div class="footerProgramming"></div>
	</ul>
	</div>
	<!-- Retro gaming -->
	<div class="menu">
	<ul>
	  <li><a href="/retrogaming/index.html" title="Retro gaming"><div class="headerRetrogaming"></div></a>
	    <ul>
	      <li><div class="linksRetrogaming"><a class="linkpopup" href="/retrogaming/index.html">Retro Gamer articles</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/rg_04_pias.html" title="An article exploring the music chip from the Commodore 64">Play it again, SID</a></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/rg_08_bubblebobble.html" title="A trip to the wonderful world of Taito's Bubble Bobble">Bubble Trouble</a></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/rg_17_playtowin.html" title="Ever wondered who won all those fantastic 80s game competitions?">Play to Win</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksRetrogaming"><a class="linkpopup" href="/retrogaming/index.html">Arcade projects</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/mamecab.html" title="My upright MAME arcade cabinet">MAME Cabinet</a></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/drivingcab.html" title="A sit-down 'cockpit'-style driving cabinet">Driving Cabinet</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksRetrogaming"><a class="linkpopup" href="/retrogaming/index.html">Game guides</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/retrogaming/bbguide/index.html" title="Complete level guide for Bubble Bobble">Bubble Bobble</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	    </ul>
	  </li>
	  <li><div class="footerRetrogaming"></div>
	</ul>
	</div>
	<!-- Ringtones -->
<!--
	<div class="menu">
	<ul>
	  <li><a href="/nokia/index.html" title="Ring-tones"><div class="headerRingtones"></div></a>
	    <ul>
	      <li><div class="linksRingtones"><a class="link" href="/nokia/tones.html">Polyphonic ring-tones</a></div></li>
	      <li><div class="linksRingtones"><a class="link" href="/nokia/howto_ringtones_index.html">Transferring via WAP</a></div></li>
	    </ul>
	  </li>
	  <li><div class="footerRingtones"></div>
	</ul>
	</div>
-->
	<!-- Psion software -->
	<div class="menu">
	<ul>
	  <li><a href="/psion/index.html" title="Psion software"><div class="headerPsion"></div></a>
	    <ul>
	      <li><div class="linksPsion"><a class="linkpopup" href="/psion/index.html">EPOC software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/psion/epoc_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="linksSubMenu"><a href="/psion/epoc_reaction.html" title="Explosive turn-based strategy game">Chain Reaction</a></div></li>
	        <li><div class="linksSubMenu"><a href="/psion/epoc_blobs.html" title="Fast paced Tetris-style game">Blobs</a></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	      <li><div class="linksPsion"><a class="linkpopup" href="/psion/index.html">SIBO software</a></div>
	        <ul>
	        <li><div class="headerSubMenu"></div></li>
	        <li><div class="linksSubMenu"><a href="/psion/sibo_tilefall.html" title="Addictive tile-based strategy game">Tile Fall</a></div></li>
	        <li><div class="linksSubMenu"><a href="/psion/sibo_reaction.html" title="Explosive turn-based strategy game">Chain Reaction</a></div></li>
	        <li><div class="footerSubMenu"></div></li>
	        </ul>
	      </li>
	    </ul>
	  </li>
	  <li><div class="footerPsion"></div>
	</ul>
	</div>
	<!-- Amiga -->
	<div class="menu">
	<ul>
	  <li><a href="/amiga/index.html" title="Amiga software"><div class="headerAmiga"></div></a>
	    <ul>
	      <li><div class="linksAmiga"><a class="link" href="/amiga/index.html">Amiga software</a></div></li>
	    </ul>
	  </li>
	  <li><div class="footerAmiga"></div>
	</ul>
	</div>
	<!-- Miscellaneous -->
	<div class="menu">
	<ul>
	  <li><a href="/misc/index.html" title="Miscellaneous"><div class="headerMisc"></div></a>
	    <ul>
	      <li><div class="linksMisc"><a class="link" href="/oldnews.html">Old news</a></div></li>
	      <li><div class="linksMisc"><a class="link" href="/misc/links.html">Links</a></div></li>
	      <li><div class="linksMisc"><a class="link" href="/misc/donate.html">Donate</a></div></li>
	      <li><div class="linksMisc"><a class="link" href="/misc/contact.html">Contact me</a></div></li>
	    </ul>
	  </li>
	  <li><div class="footerMisc"></div>
	</ul>
	</div>
	<!-- Search -->
	<div class="navBox">
		<div class="headerSearch"></div>
		<div class="linksSearch" style="padding-bottom:8px">
			<div style="margin-left:6px">
			<!-- SiteSearch Google -->
			<FORM method=GET action="http://www.google.com/search">
			<input type=hidden name=ie value=UTF-8>
			<input type=hidden name=oe value=UTF-8>
			<center>
			
			<A HREF="http://www.google.com/"><img style="margin-bottom:10px" src="/styles/images/google-logo.gif" width="81" height="34" alt="Google" border="0"></A><br>
			<INPUT TYPE=text name=q size=21 maxlength=255 value="" style="text-align: center">
			<INPUT style="margin-top:5px" type=submit name=btnG VALUE="Search this site">
			<input type=hidden name=domains value="adamdawes.com"><input type=hidden name=sitesearch value="adamdawes.com" checked>
			</center>
			</FORM>
			<!-- SiteSearch Google -->
			</div>
		</div>
		<div class="footerSearch"></div>
	</div>


    <div class="headerSubMenu-preload"></div>
    <div class="linksSubMenu-preload"></div>
    <div class="footerSubMenu-preload"></div>

	
	<div id="minilogo"></div>
	
	
	
</td>
<td class="rightColumn">

	<div id="topNavigation">
		<div id="utilityLinks">
			<a href="/misc/contact.html" class="contact"></a>
			<a href="/misc/contact.html" class="contact-preload"></a>
			<a href="/index.html" class="home"></a>
			<a href="/index.html" class="home-preload"></a>
			<a href="http://twitter.com/AdamDawes575" style="float: right; height: 36px; overflow: hidden; margin-right: 20px;">
				<img src="/styles/images/twitter.png" />
		 	</a>
		 	<br clear="all">
		</div>
	</div>

	<div id="contentHeader">
		<div id="contentHeaderLeft"></div>
		<div id="contentHeaderMid"></div>
		<div id="contentHeaderRight"></div>
	</div>
	<div id="contentFrame">
	
		<div id="content">

    <!-- PAGE CONTENT STARTS HERE -->

    <div id="breadcrumbs"><a href="/index.html">Home</a><a href="../index.html">Programming</a><a href="index.html">Tokamak Physics</a>Tutorial 2, colliding cubes</div>

    <img align="right" src="files/TutImage2.jpg" alt="Tutorial screenshot">
    <h2>Tutorial 2, colliding cubes</h2>
    
    <p>Now its time to get started with using the Tokamak engine in our project. 
    This tutorial is fairly simple but due to the nature of the physics engine 
    it's great fun to watch. I must have run this program hundreds of times now 
    just to watch it over and over again (perhaps I'm just easily pleased!).</p>

    <p>This tutorial will model dropping a number of cubes positioned vertically 
    above one another so that they fall to the floor beneath. When they hit the 
    floor they will begin to stack up on top of one another until after a short 
    while the stack becomes unbalanced, which usually results in it collapsing 
    completely to the floor, sending the cubes flying in all directions. The zip 
    file at the bottom of the tutorial contains an executable for the project 
    (as well as all the source code) if you want to have a look at what it does 
    before getting back to how it does it.</p>

    <p>Before we get carried away we need to do a little preparation: we need to 
    configure the C++ compiler so that it is able to use the Tokamak engine, and 
    we need to understand a little of what we're going to be doing.</p>

    <h3>Compiler configuration</h3>

    <p>Before we can write any code that uses the Tokamak engine we need to 
    install the SDK. This can be downloaded from the
    <a href="http://www.tokamakphysics.com">Tokamak Physics</a> web site. At the 
    time of writing the latest version (against which these tutorials have been 
    compiled) is v1.0.8. The Tokamak team release new versions containing 
    enhancements and bug fixes on a regular basis, but hopefully the later 
    versions will continue to work with these tutorials. Once the SDK is 
    downloaded, extract all of the files to your hard drive (making sure to keep 
    the directory structure that is present within the zip file).</p>

    <p>There are two primary components of the SDK that we'll need in order to 
    compile our code. The first is the .lib file that we need to link with. This 
    contains the actual compiled program code that forms the Tokamak engine. 
    Secondly we'll need the include files in order for the compiler to know how 
    to communicate with Tokamak.lib.</p>

    <p>So that MSVC knows how to find these files, we need to add the 
    appropriate folders to the IDE. To accomplish this in MSVC6, follow these 
    steps (the procedure may be different for MSVC .net):</p>
    
    <ul>
        <li>Select Tools&gt;Options from the MSVC menu
        <li>Click on the Directories tab
        <li>Ensure "Include files" is selected in the "Show directories for" list
        <li>Double-click the empty box at the bottom of the directory list so that it becomes editable
        <li>Click the "..." button and browse to the "include" folder in the location where the SDK was extracted
        <li>Click OK to return to the Options window; the path should now be present in the directory list.
    </ul>

    <p>Once this is done, change "Show directories for" to show the directories 
    for Library files. Repeat the above steps, browsing to the "lib" folder of 
    the SDK. Once this is finished, click OK on the Options window to return to 
    the main IDE.</p>

    <p>The compiler is now configured for using the Tokamak SDK. These steps 
    only need to be performed once and are not required the next time you start 
    up MSVC.</p>

    <h3>Understanding the physics engine</h3>

    <p>The Tokamak engine has quite a number of variables and parameters that 
    can affect the way in which it works. For this sample we'll be keeping 
    things as basic as possible but there are some terms that need explaining 
    before we get started.</p>

    <p>Tokamak hinges around a class called <code>neSimulator</code>. This class 
    is used to access all of the items of the physics engine and is also 
    responsible for updating the positions of all the objects as the simulation 
    runs.</p>

    <p>There are two main types of object used in the simulation: rigid bodies 
    and animated bodies. Rigid bodies are those for which the movement is 
    completely controlled by the simulator; animated bodies are those for which 
    the simulator will never change the position, these bodies are only ever 
    repositioned by the application itself. For our sample, the floor will be an 
    animated body and the cubes we drop towards it will be rigid bodies.</p>

    <h3>Bring on the code</h3>

    <p>So, let's get started with the code that will drive the application.</p>

    <p>The very first thing we need to do is include the "tokamak.h" header so 
    that the compiler knows about the functions available on tokamak.lib. We 
    also need to instruct the linker to include tokamak.lib when building the 
    final executable. This can be achieved using the Project Settings dialog, 
    but I prefer to use the #pragma compiler directive (it's easier to spot the 
    libraries that are used, and it doesn't get lost when changing between Debug 
    and Release builds).</p>
    
<blockquote class="code">
#include &lt;tokamak.h&gt;
#pragma comment(lib, "tokamak.lib")
</blockquote>

    <p>Next we initialise a few variables for Tokamak itself. These should 
    probably be nicely packaged into a class but for the sake of simplicity 
    they're simply defined as globals in this code.</p>

<blockquote class="code">
// Global variables for Tokamak
neSimulator *gSim = NULL;
// The number of cubes to render in the simulation (try values between 2 and about 50)
#define CUBECOUNT 5
neRigidBody *gCubes[CUBECOUNT];
neAnimatedBody *gFloor = NULL;
</blockquote>

    <p><code>gSim</code> is the simulator object itself. Then we have an array 
    of rigid bodies, each of which will represent one cube in our simulation, 
    and a single animated body to represent the floor. The only other addition 
    to this section of code is the vertex data for the floor 
    (<code>vbFloor</code> is the vertex buffer, and <code>gFloorVertices</code> 
    holds the floor vertex positions).</p>

    <p>The next change is to the <code>WinMain</code> procedure. Along with all 
    the other initialisation and shutdown functions, two new functions are 
    called: <code>InitPhysics</code> is responsible for initialising the 
    simulation and positioning all the objects ready for the application to 
    start, and <code>KillPhysics</code> tidies everything up once we're 
    finished.</p>

    <p>Let's take a look now at <code>InitPhysics</code>. After declaring some 
    variables for use within the code we start to prepare for creating the main 
    simulator object.</p>

    <p>The first thing the simulator needs when it is created is a 
    <code>neSimulatorSizeInfo</code> object, populated with information about 
    the bodies that are going to be simulated. This needs to be provided up-
    front so that Tokamak can allocate all the required memory before the 
    simulation begins. This is quite significant as it means you need to know 
    the maximum number of objects you will need to simulate at the point of 
    initialisation.</p>

    <p>The relevant information for the moment is the number of rigid and 
    animated bodies, and the maximum number of simultaneous "overlapped pairs" 
    of objects possible within the simulation (an overlapped pair represents the 
    potential collision between any two objects). This isn't quite as nasty as 
    it sounds, and can be calculated using a fairly simple formula as shown 
    below.</p>

    <p>The code so far to prepare the neSimulatorSizeInfo object is as follows:</p>
    
<blockquote class="code">
// Initialise the Tokamak physics engine.
// Here's where the interesting stuff starts.
bool InitPhysics(void)
{
    neGeometry *geom;    // A Geometry object which used to define the shape/size of each cube
    neV3 boxSize1;       // A variable to store the length, width and height of the cube
    neV3 gravity;        // A vector to store the direction and intensity of gravity
    neV3 pos;            // The position of a cube
    f32 mass;            // The mass of our cubes
    neSimulatorSizeInfo sizeInfo;    // Stores data about how many objects we are going to model
    int i;

    // Create and initialise the simulator
    // Tell the simulator how many rigid bodies we have
    sizeInfo.rigidBodiesCount = CUBECOUNT;
    // Tell the simulator how many animated bodies we have
    sizeInfo.animatedBodiesCount = 1;
    // Tell the simulator how many bodies we have in total
    s32 totalBody = sizeInfo.rigidBodiesCount + sizeInfo.animatedBodiesCount;
    sizeInfo.geometriesCount = totalBody;
    // The overlapped pairs count defines how many bodies it is possible to be in collision
    // at a single time. The SDK states this should be calculated as:
    //   bodies * (bodies-1) / 2
    // So we'll take its word for it. :-)
    sizeInfo.overlappedPairsCount = totalBody * (totalBody - 1) / 2;
    // We're not using any of these so set them all to zero
    sizeInfo.rigidParticleCount = 0;
    sizeInfo.constraintsCount = 0;
    sizeInfo.terrainNodesStartCount = 0;
</blockquote>

    <p>The other thing required to initialise the simulator is a vector that 
    represents gravity. Normally gravity is obviously directed straight down 
    (with a negative <code>y</code> value), but you can have gravity set to be 
    in any direction you like -- including upwards if you want. Larger values 
    represent a stronger pull along the appropriate axis. We set the gravity 
    direction as follows:</p>

<blockquote class="code">
    // Set the gravity. Try changing this to see the effect on the objects
    gravity.Set(0.0f, -10.0f, 0.0f);
</blockquote>

    <p>With the size and gravity data all set we can finally create the 
    simulator object.</p>

<blockquote class="code">
    // Ready to go, create the simulator object
    gSim = neSimulator::CreateSimulator(sizeInfo, NULL, &amp;gravity);
</blockquote>

    <p>With the simulator created we are ready to create the objects we wish to 
    simulate. We'll set up a loop for each of our cubes, and get the simulator 
    to create a rigid body for each one. The pointer to the rigid body is placed 
    into the <code>gCubes</code> array.</p>
    
<blockquote class="code">
    // Create rigid bodies for the cubes
    for (i=0; i&lt;CUBECOUNT; i++)
    {
        // Create a rigid body
        gCubes[i] = gSim-&gt;CreateRigidBody();
</blockquote>

    <p>The simulator now knows that we have a rigid body, but it doesn't know 
    anything about its shape or size. Tokamak uses three primitives to represent 
    the shape of an object that it is going to simulate. These are the box, 
    cylinder and sphere. Each time you add a body to the simulation you will 
    need to create the geometry for the body using these primitives. A body may 
    have multiple geometries associated with it if it has a more complex shape, 
    but as we are only modelling cubes in this tutorial we can simply use a 
    single box primitive for our geometry.</p>

    <p>In the code below we set the size of the box to (1, 1, 1). These values 
    match with those used in the vertex data for the cube at the top of the 
    source code (the cube extends from -0.5 to +0.5 along each axis, giving a 
    size of 1.0). The three values used below correspond to the X, Y and Z axes 
    respectively; changing the size of the cube in the vertex data will require 
    the values below to be updated accordingly if the simulated object is to 
    match its representation drawn on the screen.</p>

    <p>Every time the geometry for a body is set or modified, the 
    <code>UpdateBoundingInfo</code> method of the object must be called. This 
    instructs Tokamak to update its simulation for the geometry data that has 
    been set. If this is not called, your objects will probably fall straight 
    through the floor without ever colliding with it.</p>
    
<blockquote class="code">
        // Add geometry to the body and set it to be a box of dimensions 1, 1, 1
        geom = gCubes[i]-&gt;AddGeometry();
        boxSize1.Set(1.0f, 1.0f, 1.0f);
        geom-&gt;SetBoxSize(boxSize1[0], boxSize1[1], boxSize1[2]);
        // Update the bounding info of the object -- must always call this
        // after changing a body's geometry.
        gCubes[i]-&gt;UpdateBoundingInfo();
</blockquote>

    <p>Next we set some other properties of the body: mass and the inertia 
    tensor. The mass of an object represents how "heavy" it is in relation to 
    other objects in the scene. If an object with a small mass collides with an 
    object with a large mass, the large mass object will be relatively less 
    affected. This is not so easy to see in this simulation as all the cubes 
    have the same mass value.</p>

    <p>The inertia tensor is similar to mass, but whereas mass relates to the 
    change in position of an object, the inertia tensor relates to the change in 
    rotation of an object. We'll use the helper function 
    <code>neBoxInertiaTensor</code> to set this for us; remember to use the help 
    function that corresponds to the type of geometry that's been used for the 
    body.</p>

<blockquote class="code">
        // Set other properties of the object (mass, position, etc.)
        mass = 1.0f;
        gCubes[i]-&gt;SetInertiaTensor(neBoxInertiaTensor(boxSize1[0], boxSize1[1], boxSize1[2], mass));
        gCubes[i]-&gt;SetMass(mass);
</blockquote>

    <p>Finally we just need to position the cube in space ready for it to be 
    simulated. For this application, we'll position each cube vertically one 
    above the other with a gap between each. All the cubes will be dropped 
    simultaneously however, so cubes higher up will be travelling faster by the 
    time they reach the ground due to the increased acceleration of gravity 
    acting upon them. We'll also provide a slight randomisation on the X and Z 
    axes so that the stack is more likely to fall over (it makes it much more 
    interesting to watch).</p>

<blockquote class="code">
        // Vary the position so the cubes don't all exactly stack on top of each other
        pos.Set((float)(rand()%10) / 100, 4.0f + i*2.0f, (float)(rand()%10) / 100);
        gCubes[i]-&gt;SetPos(pos);
    }
</blockquote>

    <p>And that's all our cubes ready to run. If it looked complicated, try 
    changing some of the values around and running the simulation to see what 
    effect the changes have on the cubes.</p>

    <p>Next we need to create the animated body that will represent the floor. 
    This is all pretty much identical to how we created the cubes, except the we 
    call <code>CreateAnimatedBody</code> instead of 
    <code>CreateRigidBody</code>. We'll set the floor to have very little 
    height, and to have its width and depth as defined by our FLOORSIZE 
    constant. We'll also set the floor so that it's centered on the X and Z 
    axes, but positioned a little way below the origin on the Y axis.</p>

<blockquote class="code">
    // Create an animated body for the floor
    gFloor = gSim-&gt;CreateAnimatedBody();
    // Add geometry to the floor and set it to be a box with size as defined by the FLOORSIZE constant
    geom = gFloor-&gt;AddGeometry();
    boxSize1.Set(FLOORSIZE, 0.2f, FLOORSIZE);
    geom-&gt;SetBoxSize(boxSize1[0],boxSize1[1],boxSize1[2]);
    gFloor-&gt;UpdateBoundingInfo();
    // Set the position of the box within the simulator
    pos.Set(0.0f, -3.0f, 0.0f);
    gFloor-&gt;SetPos(pos);

    // All done
    return true;
}
</blockquote>

    <p>That's the end of <code>InitPhysics</code>, from here our similation is 
    ready to run. <code>KillPhysics</code> simply releases the simulator object 
    (if it's been set). This will automatically clear up all bodies, geometry 
    and other objects that have been associated with the simulator so there's no 
    need to tidy up any further than this.</p>

<blockquote class="code">
void KillPhysics(void)
{
    if (gSim)
    {
        // Destroy the simulator.
        // Note that this will release all related resources that we've allocated.
        neSimulator::DestroySimulator(gSim);
        gSim = NULL;
    }
}
</blockquote>

    <p>The final addition to the code in unsurprisingly in the 
    <code>Render</code> function. There are two new things we do here: firstly 
    we advance the simulation so that it updates all the positions of the 
    objects, and secondly we draw the objects to the screen.</p>

    <p>The simulation is advanced by calling the <code>Advance</code> method of 
    the simulator object. This method expects the amount of time that has passed 
    since the last time we made the call to be passed so that it knows how far 
    to move each object in the simulation.</p>

    <p>There are also two optional parameters to <code>Advance</code>: the 
    first, <code>nSteps</code> is the number of sub-divisions of the time frame 
    to be used for object calculations. For example, if 1/60th of a second has 
    passed, we could call with 1/60 as the time parameter, passing 1 for the 
    number of steps. If we passed 2 for steps, it would be equivalent to calling 
    Advance twice with 1/120 as the time parameter and a step of 1. Larger 
    values of step provide a more "accurate" simulation but at the cost of 
    decreased performance. For most purposes a step of 1 is sufficient.</p>

    <p><code>Advance</code> is also able to return a performance report object 
    so that we can query how long it took working on each part of the simulation 
    update. This is not something used in this tutorial, however.</p>

    <p>As we can use our timer to determine exactly how much time has passed (in 
    seconds), we'll use this value to ensure that the simulation always runs at 
    the same speed, regardless of frame rate or processing power. However, one 
    slight complication with this method is that the Tokamak engine works best 
    with a fairly constant time interval passed each time it updates. Unexpected 
    variations can cause the stability of the engine to fluctuate, often 
    resulting in extreme movement of the objects being simulated.</p>

    <p>To avoid this, we'll try to ensure that the elapsed time never varies by 
    more than 20% of what is was the previous time we called 
    <code>Advance</code>. We will also ensure that no time interval lasts longer 
    than 1/45th of a second, as updates slower than this can also cause problems 
    within the simulation. The following code retrieves the elapsed time and 
    smooths out the values based on these principles. <font size="-2">[Thanks to 
    Chris Chan at Tokamak for pointing this issue out to me]</font></p>
    
<blockquote class="code">
    float fElapsed;
    static float fLastElapsed;
[...]
    // Find out how much time has elapsed since we were last called
    fElapsed = GetElapsedTime();

    // Prevent the elapsed time from being more than 20% greater or
    // less than the previous elapsed time.
    if (fLastElapsed != 0)
    {
        if (fElapsed > fLastElapsed * 1.2f) fElapsed = fLastElapsed * 1.2f;
        if (fElapsed < fLastElapsed * 0.8f) fElapsed = fLastElapsed * 0.8f;
    }
    // Stop the elapsed time from exceeding 1/45th of a second.
    if (fElapsed > 1.0f / 45.0f) fElapsed = 1.0f / 45.0f;
    // Store the elapsed time so that we can use it the next time around
    fLastElapsed = fElapsed;
</blockquote>

    <p>Now that we've calculated an acceptable time period for which to advance 
    the simulation, we'll pass it to the simulator's <code>Advance</code> method 
    to update the objects.</p>

<blockquote class="code">
    gSim->Advance(fElapsed);
</blockquote>

    <p>With the simulation updated we now need to ask it for the positions of 
    each of our objects so that we can render them. We'll start with rendering 
    the floor. Even though the object won't be moved by the simulation itself 
    (it's an animated body), we'll still query the position from the engine to 
    ensure we are displaying it in the position that the engine believes it to 
    be.</p>

    <p>We retrieve the position of the floor by calling the 
    <code>GetTransform</code> method of the floor's body object. This returns a 
    matrix containing all of the positional data we need. However, it's not in 
    quite the same format that DirectX requires in order for it to set the 
    position for rendering, so we need to transfer the values out of the Tokamak 
    matrix object and into a DirectX matrix object. (For an OpenGL application, 
    this transfer would need to be modified in response to the different 
    coordinate system used by OpenGL.)</p>

    <p>Once this is done we simply set the world transformation and render the 
    floor.</p>
    
<blockquote class="code">
        // Set the vertex stream for the floor
        gD3DDevice-&gt;SetStreamSource(0,vbFloor,sizeof(strVertex));

        // Draw the floor...
        // Get the transformation matrix for the floor object
        t = gFloor-&gt;GetTransform(); 
        // Transfer the values to a D3DMatrix that we can pass to DirectX
        dxTrans = D3DXMATRIX(    t.rot[0][0], t.rot[0][1], t.rot[0][2], 0.0f, 
                    t.rot[1][0], t.rot[1][1], t.rot[1][2], 0.0f, 
                    t.rot[2][0], t.rot[2][1], t.rot[2][2], 0.0f, 
                    t.pos[0],t.pos[1], t.pos[2], 1.0f );
        // Set the world transformation so that we can draw the floor at the correct position
        gD3DDevice-&gt;SetTransform(D3DTS_WORLD, &amp;dxTrans );
        // Render the floor
        gD3DDevice-&gt;DrawPrimitive(D3DPT_TRIANGLELIST,0,2);
</blockquote>

    <p>The code to render the cubes is essentially identical, using each cube's 
    body to determine the position for rendering.</p>

<blockquote class="code">
        // Set the vertex stream for the cube
        gD3DDevice-&gt;SetStreamSource(0,vbCube,sizeof(strVertex));

        // Draw the cubes
        for (i=0; i&lt;CUBECOUNT; i++)
        {
            // Get the transformation matrix for this cube
            t = gCubes[i]-&gt;GetTransform(); 
            // Transfer the values to a D3DMATRIX that we can pass to DirectX
            dxTrans = D3DXMATRIX(    t.rot[0][0], t.rot[0][1], t.rot[0][2], 0.0f, 
                        t.rot[1][0], t.rot[1][1], t.rot[1][2], 0.0f, 
                        t.rot[2][0], t.rot[2][1], t.rot[2][2], 0.0f, 
                        t.pos[0],t.pos[1], t.pos[2], 1.0f );
            // Set the world transformation so that we can draw the cube at the correct position
            gD3DDevice-&gt;SetTransform(D3DTS_WORLD, &amp;dxTrans );
            // Render the cube
            gD3DDevice-&gt;DrawPrimitive(D3DPT_TRIANGLELIST,0,12);
        }
</blockquote>

    <p>...And that concludes the code required for this tutorial. I think you'll 
    agree that with very little code an astounding level of realism can be 
    obtained even if we are only looking at cubes on a flat surface. Because of 
    the complexity of the calculations involved and the fact that the timing 
    will not be identical every time the application runs, the simulation is 
    never the same twice. This can make it very interesting to watch but also 
    potentially unpredictable in practise so be careful!</p>

    <p>Feel free to experiment with changing the number of cubes simulated, the 
    floor size, gravity, and even the size of the cubes (it's very little work 
    to make them look like dominos).</p>

    <p>The source code and a compiled executable for this tutorial are available in the following .zip file.</p>
    
    <center>
    <a href="files/TokamakTutorial2.zip"><img src="../../gfx/ico_zip.gif" border="0" alt="Zip icon"></a>
    <br>
    <a href="files/TokamakTutorial2.zip">TokamakTutorial2.zip</a>
    </center>
 
    <table width="100%">
     <tr>
      <td align="left">&lt;&lt; <a href="01_Framework.html">Tutorial 1, the DirectX framework</a> &lt;&lt;</td>
      <td align="right">&gt;&gt; <a href="03_CylindersAndSpheres.html">Tutorial 3, cylinders and spheres</a> &gt;&gt;</td>
     </tr>
    </table>
 
    <hr>
    <p>If you have any comments or suggestions regarding this article, please don't hesitate to <a href="../../misc/contact.html">contact me</a>.</p>
    <p align="right"><font size=-2>This article is copyright &copy; Adam Dawes, 2003.<br>It may not be copied or redistributed without my express written permission.</font></p>

    <!-- PAGE CONTENT ENDS HERE -->

    		</div>
		
	</div>

	<div id="contentFooter">
		<div id="contentFooterLeft"></div>
		<div id="contentFooterMid"></div>
		<div id="contentFooterRight"></div>
	</div>

</td></tr>
</table>

<script type="text/javascript">
//<![CDATA[
(function() {
	var links = document.getElementsByTagName('a');
	var query = '?';
	for(var i = 0; i < links.length; i++) {
		if(links[i].href.indexOf('#disqus_thread') >= 0) {
			query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
		}
	}
	document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/adamdawes/get_num_replies.js' + query + '"></' + 'script>');
})();
//]]>
</script>

</body>

</html>
